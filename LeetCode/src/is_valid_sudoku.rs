pub struct Solution;
impl Solution {
  pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool {
    for row in board {
      for (idx, chunk) in row.iter().enumerate() {
        if chunk == &'.' {
          print!("{:?} ", chunk);
          continue;
        }
        print!("{:?} ", chunk);
      }
    }

    true
  }
}

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_valid_board() {
    let board = vec![
      vec!['5', '3', '.', '.', '7', '.', '.', '.', '.'],
      vec!['6', '.', '.', '1', '9', '5', '.', '.', '.'],
      vec!['.', '9', '8', '.', '.', '.', '.', '6', '.'],
      vec!['8', '.', '.', '.', '6', '.', '.', '.', '3'],
      vec!['4', '.', '.', '8', '.', '3', '.', '.', '1'],
      vec!['7', '.', '.', '.', '2', '.', '.', '.', '6'],
      vec!['.', '6', '.', '.', '.', '.', '2', '8', '.'],
      vec!['.', '.', '.', '4', '1', '9', '.', '.', '5'],
      vec!['.', '.', '.', '.', '8', '.', '.', '7', '9'],
    ];
    assert_eq!(Solution::is_valid_sudoku(board), true);
  }

  #[test]
  fn test_invalid_row() {
    let board = vec![
      vec!['5', '3', '.', '.', '7', '.', '.', '3', '.'], // duplicate '3' in row
      vec!['6', '.', '.', '1', '9', '5', '.', '.', '.'],
      vec!['.', '9', '8', '.', '.', '.', '.', '6', '.'],
      vec!['8', '.', '.', '.', '6', '.', '.', '.', '3'],
      vec!['4', '.', '.', '8', '.', '3', '.', '.', '1'],
      vec!['7', '.', '.', '.', '2', '.', '.', '.', '6'],
      vec!['.', '6', '.', '.', '.', '.', '2', '8', '.'],
      vec!['.', '.', '.', '4', '1', '9', '.', '.', '5'],
      vec!['.', '.', '.', '.', '8', '.', '.', '7', '9'],
    ];
    assert_eq!(Solution::is_valid_sudoku(board), false);
  }

  #[test]
  fn test_invalid_column() {
    let board = vec![
      vec!['5', '3', '.', '.', '7', '.', '.', '.', '.'],
      vec!['6', '.', '.', '1', '9', '5', '.', '.', '.'],
      vec!['5', '9', '8', '.', '.', '.', '.', '6', '.'], // duplicate '5' in column 0
      vec!['8', '.', '.', '.', '6', '.', '.', '.', '3'],
      vec!['4', '.', '.', '8', '.', '3', '.', '.', '1'],
      vec!['7', '.', '.', '.', '2', '.', '.', '.', '6'],
      vec!['.', '6', '.', '.', '.', '.', '2', '8', '.'],
      vec!['.', '.', '.', '4', '1', '9', '.', '.', '5'],
      vec!['.', '.', '.', '.', '8', '.', '.', '7', '9'],
    ];
    assert_eq!(Solution::is_valid_sudoku(board), false);
  }

  #[test]
  fn test_invalid_subgrid() {
    let board = vec![
      vec!['5', '3', '.', '.', '7', '.', '.', '.', '.'],
      vec!['6', '.', '3', '1', '9', '5', '.', '.', '.'], // duplicate '3' in top-left 3x3 box
      vec!['.', '9', '8', '.', '.', '.', '.', '6', '.'],
      vec!['8', '.', '.', '.', '6', '.', '.', '.', '3'],
      vec!['4', '.', '.', '8', '.', '3', '.', '.', '1'],
      vec!['7', '.', '.', '.', '2', '.', '.', '.', '6'],
      vec!['.', '6', '.', '.', '.', '.', '2', '8', '.'],
      vec!['.', '.', '.', '4', '1', '9', '.', '.', '5'],
      vec!['.', '.', '.', '.', '8', '.', '.', '7', '9'],
    ];
    assert_eq!(Solution::is_valid_sudoku(board), false);
  }

  #[test]
  fn test_empty_board() {
    let board = vec![vec!['.'; 9]; 9];
    assert_eq!(Solution::is_valid_sudoku(board), true);
  }
}
