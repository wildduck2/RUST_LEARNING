# Roadmap: Building a CSS Language Server in Rust

## Phase 1: Master Rust Fundamentals  
- **Ownership & Borrowing:** Learn Rust’s core concepts (ownership, borrowing, lifetimes, traits) so you write safe, efficient code. Resources like *The Rust Programming Language* (“the Rust Book”) and *Rust By Example* cover these in detail.  
- **Tooling & Workflow:** Become comfortable with Cargo (package manager), Clippy (linting), and Rustfmt (formatting). Build small CLI tools or libraries to practice module organization and error handling. For example, parse a text file or JSON to get used to I/O and `Result`/`Option`.  
- **Async Programming:** Study Rust’s `async`/`await` syntax and pick a runtime (Tokio or async-std). Write simple asynchronous programs (e.g. a TCP echo server) to understand concurrency. LSP servers handle multiple requests concurrently, so async skills are essential.  
- **Macros & Code Generation:** Learn how macros work. Tower-LSP uses attribute macros like `#[tower_lsp::async_trait]` to simplify async trait methods. Practice by writing a custom derive or declarative macro to automate repetitive code.  
- **Memory Management:** Reinforce how Rust’s ownership model and borrow checker prevent memory bugs. This ensures the LSP server (a long-running process) stays stable without garbage collection.  
- **Milestone:** Complete a few Rust projects (like a simple web server or file processor) and explore crates (e.g. using `serde` for JSON) to become fluent in idiomatic Rust code.

## Phase 2: Understand LSP and Setup Tooling  
- **LSP Fundamentals:** Read the official Language Server Protocol spec/overview. The LSP defines a **JSON-RPC** protocol between an editor and a language server, enabling features like auto-complete, go-to-definition, hover, etc ([Official page for Language Server Protocol](https://microsoft.github.io/language-server-protocol#:~:text=The%20Language%20Server%20Protocol%20,copy%20of%20the%20source%20code)) ([Official page for Language Server Protocol](https://microsoft.github.io/language-server-protocol#:~:text=The%20protocol%20defines%20the%20format,store%20information%20about%20programming%20artifacts)). Study how requests and notifications (e.g. `textDocument/didOpen`, `textDocument/hover`) are formatted.  
- **Tower-LSP Crate:** Use the [tower-lsp](https://crates.io/crates/tower-lsp) crate, which “provides a simple implementation of the Language Server Protocol (LSP) that makes it easy to write your own language server” ([GitHub - ebkalderon/tower-lsp: Language Server Protocol implementation written in Rust](https://github.com/ebkalderon/tower-lsp#:~:text=This%20library%20%28%60tower,It%20consists%20of%20three%20parts)). It supplies a `LanguageServer` trait for your server logic, an `LspService` that handles protocol details, and a `Server` to run over stdio or TCP.  
- **LSP Types:** Depend on the `lsp-types` crate for Rust definitions of all LSP messages, capabilities, and data structures. The Rust community notes that “the lsp-types crate… helps with the all around” development of an LSP server ([Rust tutorial on writing a lsp server? - The Rust Programming Language Forum](https://users.rust-lang.org/t/rust-tutorial-on-writing-a-lsp-server/75570#:~:text=building%20a%20LSP%20server%20is,helps%20with%20the%20all%20around)). This saves you from manually defining JSON message formats.  
- **Example “Hello World” Server:** Implement a minimal server with Tower-LSP. For instance, handle `initialize` by returning default capabilities, log a message on `initialized`, and cleanly handle `shutdown`. The [tower-lsp README][7] shows an example where a `Backend` struct implements a few LSP methods. Confirm the server runs (e.g., spawn it manually and send a sample JSON request).  
- **Learning Resources:** Browse the `tower-lsp` GitHub examples and community projects. For example, the Tower-LSP repo has example servers, and community repos like *nix-language-server* or the “nano_rust” example demonstrate more features ([Rust tutorial on writing a lsp server? - The Rust Programming Language Forum](https://users.rust-lang.org/t/rust-tutorial-on-writing-a-lsp-server/75570#:~:text=I%20don%27t%20know%20specifically%20of,lsp)). These show how to maintain file state and implement common handlers.  
- **Milestone:** Have a Rust program that launches as an LSP server (e.g., reads from stdin/stdout) and responds to an `initialize` request. Use a simple LSP client (or even `ncat`/`curl`) to verify basic communication.

## Phase 3: Build Core CSS Language Features  
- **CSS Parsing:** Integrate a CSS parser to analyze code. A recommended choice is the [cssparser](https://docs.rs/cssparser) crate, which implements the CSS Syntax Level 3 specification ([cssparser - Rust](https://docs.rs/cssparser/#:~:text=Expand%20description)). Use it to tokenize and parse rules, selectors, and declarations. Alternatively, you could invoke an external parser (e.g. call the TypeScript CSS parser or PostCSS via a child process), but leveraging a Rust library keeps everything in one language.  
- **Leveraging Existing Parsers:**  It’s often best to rely on a proven parser for accuracy. For example, the Postgres LSP uses the official Postgres parser (`libpg_query`) to ensure 100% correctness ([Postgres Language Server | Hacker News](https://news.ycombinator.com/item?id=37020610#:~:text=This%20attempt%20is%20different%20because,the%20rapid%20development%20of%20Postgres)). Similarly, using `cssparser` (or even a binding to an official CSS engine) means you inherit full CSS3 support and up-to-date parsing rules.  
- **Diagnostics:** On each document change, run the CSS parser. Catch syntax errors and report them as LSP diagnostics (`publishDiagnostics`). For example, if parsing fails at a character, send a diagnostic with the error position. This gives real-time error checking in the editor.  
- **Hover Information:** Provide helpful info when the user hovers over a CSS token. For CSS property names or values, look up documentation (e.g., from MDN or W3C specs) and return it as hover text. You could embed a small database of CSS properties or fetch definitions. For colors or units, show explanations or previews.  
- **Completion:** Implement `textDocument/completion` to suggest CSS constructs. This typically includes property names (e.g. “color”, “margin”), values (“red”, “10px”), and possibly HTML classes/ids if in scope. Use a static list of properties (many are easily found online) or extract them from the parser’s data. Return completion items with snippets or detail strings.  
- **Go-to-Definition:** In CSS, this could mean jumping to the definition of a custom CSS variable (like `--main-bg-color`) or jumping from a class usage in HTML to its rule in CSS. To support this, you may need to parse the entire workspace: index symbol declarations (classes, ids, variables) and respond to `textDocument/definition` by locating where that symbol was defined.  
- **Formatting:** For code formatting (`textDocument/formatting`), you can either implement a CSS pretty-printer or call an external formatter. There are Rust crates (like [parcel_css](https://crates.io/crates/parcel_css) from Parcel) that can format and minify CSS. Integrate one as a formatting command in your server.  
- *Milestone:* The LSP server can parse a CSS file, underline syntax errors, and provide hover and completion for at least basic properties. Try it in an editor: open a `.css` file and check that errors and hovers appear.

## Phase 4: Advanced LSP Features  
- **Rename Refactoring:** Implement `textDocument/rename` so developers can rename symbols (e.g. CSS variables or classes) across the file or project. You’ll need to find all occurrences and apply workspace edits. This typically requires a symbol index (populated during parsing) to know where each identifier appears.  
- **Code Actions:** Offer quick-fix or context actions. For example, if a property is misspelled, suggest the correct one. Or provide actions like “Add vendor prefix” by calling an autoprefixer. Implement `textDocument/codeAction` to return actionable fixes or refactorings based on diagnostics.  
- **Workspace Symbols & Go-to-References:** Implement `workspace/symbol` to list all CSS symbols (like classes, IDs, keyframes). Also `textDocument/references` to find all references to a symbol. This helps navigating large CSS projects.  
- **Optimizations:** As features grow, ensure the server remains fast. Use Rust’s concurrency to parse files in parallel if needed. Keep an in-memory cache of parsed ASTs for open files to avoid reparsing everything on each edit. Clippy can suggest performance improvements.  
- **Memory Safety:** Rust’s ownership means you don’t have to worry about manual memory management; focus on logical correctness. Use tools like `cargo audit` to keep dependencies secure.  
- *Milestone:* The server supports rename, can list workspace symbols, and offers at least one useful code action. It works smoothly on a medium-sized stylesheet without lag.

## Phase 5: Testing, Debugging, and Deployment  
- **Unit and Integration Tests:** Write unit tests for your CSS parsing logic and any complex transformations. For LSP integration, consider writing tests that simulate LSP requests (the `tower-lsp` crate allows you to manually send JSON requests to your server instance). This ensures responses (like diagnostics or completions) match expectations.  
- **Debug Logging:** Add logging (`log` or `tracing` crates) in key parts of your server (parsing, request handlers). Run the server with `RUST_LOG=debug` to see detailed LSP traffic. In an editor, you can view logs (VS Code’s Output panel or Neovim’s `:LspLog`) to trace issues.  
- **Editor Integration:**  
  - **VS Code:** Create a minimal extension or use the [Language Client](https://code.visualstudio.com/api/language-extensions/language-server-extension-guide) setup that launches your Rust server. Use a launch configuration (in `.vscode/launch.json`) to run the server with debugging. Test features in a live workspace.  
  - **Neovim:** Configure [nvim-lspconfig](https://github.com/neovim/nvim-lspconfig) to point to your server binary for CSS files. You might need a small Lua script to locate the executable and set filetypes. Use `vim.lsp.buf.hover()`, `vim.lsp.buf.definition()`, etc., to invoke LSP actions.  
- **Performance Testing:** Benchmark the server on large CSS files (thousands of lines). Tools like [Criterion.rs](https://crates.io/crates/criterion) can help micro-benchmark parse times. Optimize hotspots if needed (e.g., avoid reparsing the whole file on each keystroke by diffing edits).  
- **Documentation:** Write clear docs and examples. In your README, explain how to install and run the server, and how editors can connect to it. List supported LSP features and any limitations.  
- **Continuous Integration:** Set up CI (e.g., GitHub Actions) to run tests on each commit. Include steps for `cargo fmt` and `cargo clippy` to enforce code style and catch issues early.  
- **Publishing & Community:** Package the server as a crate (include a `edition = "2021"` in Cargo). Publish to crates.io when ready. Announce your project on Rust forums or in the Tower-LSP community. The [tower-lsp-community](https://github.com/tower-lsp-community) GitHub group and Rust Discord are good places to seek feedback. Referencing examples from the community can help – for instance, there are sample servers and boilerplates available for learning ([Rust tutorial on writing a lsp server? - The Rust Programming Language Forum](https://users.rust-lang.org/t/rust-tutorial-on-writing-a-lsp-server/75570#:~:text=I%20don%27t%20know%20specifically%20of,lsp)).  
- *Milestone:* The CSS LSP server works in both VS Code and Neovim, providing diagnostics, completion, and other features. It is well-tested, documented, and publicly released.

## Key Resources  
- **Language Server Protocol (LSP) Specification:** Official docs and spec (protocol 3.17) ([Official page for Language Server Protocol](https://microsoft.github.io/language-server-protocol#:~:text=The%20Language%20Server%20Protocol%20,copy%20of%20the%20source%20code)) ([Official page for Language Server Protocol](https://microsoft.github.io/language-server-protocol#:~:text=The%20protocol%20defines%20the%20format,store%20information%20about%20programming%20artifacts)).  
- **tower-lsp Crate:** GitHub repo and examples for building LSP servers in Rust ([GitHub - ebkalderon/tower-lsp: Language Server Protocol implementation written in Rust](https://github.com/ebkalderon/tower-lsp#:~:text=This%20library%20%28%60tower,It%20consists%20of%20three%20parts)).  
- **cssparser Crate:** Rust implementation of CSS Syntax Module Level 3 ([cssparser - Rust](https://docs.rs/cssparser/#:~:text=Expand%20description)).  
- **Rust Community:** Discussions and examples (e.g. Rust forum thread about LSPs ([Rust tutorial on writing a lsp server? - The Rust Programming Language Forum](https://users.rust-lang.org/t/rust-tutorial-on-writing-a-lsp-server/75570#:~:text=building%20a%20LSP%20server%20is,helps%20with%20the%20all%20around)) ([Rust tutorial on writing a lsp server? - The Rust Programming Language Forum](https://users.rust-lang.org/t/rust-tutorial-on-writing-a-lsp-server/75570#:~:text=I%20don%27t%20know%20specifically%20of,lsp))).  
- **Editor LSP Guides:** VS Code and Neovim documentation for connecting to custom language servers.

By following this roadmap step-by-step, a beginner Rust developer can progressively build up the skills and knowledge needed to implement a full-featured CSS language server. Each phase builds on the last, from Rust basics through protocol understanding, to implementing real editor features, and finally to polishing and publishing a professional-grade tool.

**Sources:** Tower-LSP crate and docs ([GitHub - ebkalderon/tower-lsp: Language Server Protocol
implementation written in
Rust](https://github.com/ebkalderon/tower-lsp#:~:text=This%20library%20%28%60tower,It%20consists%20of%20three%20parts));
LSP official spec ([Official page for Language Server
Protocol](https://microsoft.github.io/language-server-protocol#:~:text=The%20Language%20Server%20Protocol%20,copy%20of%20the%20source%20code))
([Official page for Language Server
Protocol](https://microsoft.github.io/language-server-protocol#:~:text=The%20protocol%20defines%20the%20format,store%20information%20about%20programming%20artifacts));
Rust forum and examples ([Rust tutorial on writing a lsp server? - The Rust Programming Language
Forum](https://users.rust-lang.org/t/rust-tutorial-on-writing-a-lsp-server/75570#:~:text=building%20a%20LSP%20server%20is,helps%20with%20the%20all%20around))
([Rust tutorial on writing a lsp server? - The Rust Programming Language
Forum](https://users.rust-lang.org/t/rust-tutorial-on-writing-a-lsp-server/75570#:~:text=I%20don%27t%20know%20specifically%20of,lsp));
cssparser crate docs ([cssparser - Rust](https://docs.rs/cssparser/#:~:text=Expand%20description));
community language server experiences ([Postgres Language Server | Hacker
News](https://news.ycombinator.com/item?id=37020610#:~:text=This%20attempt%20is%20different%20because,the%20rapid%20development%20of%20Postgres)); [Rust API Guidelines](https://rust-lang.github.io/api-guidelines/#rust-api-guidelines)
